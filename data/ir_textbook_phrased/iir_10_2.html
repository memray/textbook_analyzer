challenges in xml-retrieval in this section , we discuss a number of challenges that make structured-retrieval more difficult than unstructured retrieval . recall from page 10 the basic setting we assume in structured-retrieval : the collection consists of structured-documents and queries are either structured (as in figure 10.3) or unstructured (e.g. , summer holidays) . the first challenge in structured-retrieval is that users want us to return parts of documents (i.e. , xml elements) , not entire documents as ir systems usually do in unstructured retrieval . if we query shakespeare 's plays for macbeth 's castle , should we return the scene , the act or the entire play in figure 10.2 ? in this case , the user is probably looking for the scene . on the other hand , an otherwise unspecified search for macbeth should return the play of this name , not a subunit . one criterion for selecting the most appropriate part of a document is the structured-document-retrieval principle : structured-document-retrieval principle . a system should always retrieve the most specific part of a document answering the query . title # `` macbeth '' 10.2 macbeth macbeth 's castle figure 10.5 : partitioning an xml-document into non-overlapping indexing units . parallel to the issue of which parts of a document to return to the user is the issue of which parts of a document to index . in section 2.1.2 (page) , we discussed the need for a document unit or indexing unit in indexing-and-retrieval . in unstructured retrieval , it is usually clear what the right document unit is : files on your desktop , email-messages , web-pages on the web etc. . in structured-retrieval , there are a number of different approaches to defining the indexing unit . one approach is to group nodes into non-overlapping pseudodocuments as shown in figure 10.5 . in the example , books , chapters and sections have been designated to be indexing units , but without overlap . for example , the leftmost dashed indexing unit contains only those parts of the tree dominated by book that are not already part of other indexing units . the disadvantage of this approach is that pseudodocuments may not make sense to the user because they are not coherent units . for instance , the leftmost indexing unit in figure 10.5 merges three disparate elements , the class , author and title elements . we can also use one of the largest elements as the indexing unit , for example , the book element in a collection of books or the play element for shakespeare 's works . we can then postprocess search-results to find for each book or play the subelement that is the best hit . for example , the query macbeth 's castle may return the play macbeth , which we can then postprocess to identify act i , scene vii as the best-matching subelement . unfortunately , this two-stage-retrieval process fails to return the best subelement for many queries because the relevance of a whole book is often not a good predictor of the relevance of small subelements within it . instead of retrieving large units and identifying subelements (top-down) , we can also search all leaves , select the most relevant ones and then extend them to larger units in postprocessing (bottom up) . for the query macbeth 's castle in figure 10.1 , we would retrieve the title macbeth 's castle in the first pass and then decide in a postprocessing step whether to return the title , the scene , the act or the play . this approach has a similar problem as the last one : the relevance of a leaf element is often not a good predictor of the relevance of elements it is contained in . the least restrictive approach is to index all elements . this is also problematic . many xml elements are not meaningful search-results , e.g. , typographical elements like definitely or an isbn number which can not be interpreted without context . also , indexing all elements means that search-results will be highly redundant . for the query macbeth 's castle and the document in figure 10.1 , we would return all of the play , act , scene and title elements on the path between the root-node and macbeth 's castle . the leaf node would then occur four times in the result-set , once directly and three times as part of other elements . we call elements that are contained within each other nested . returning redundant nested elements in a list of returned hits is not very user-friendly . because of the redundancy caused by nested elements it is common to restrict the set of elements that are eligible to be returned . restriction strategies include : discard all small elements discard all element types that users do not look at (this requires a working xml-retrieval system that logs this information) discard all element types that assessors generally do not judge to be relevant (if relevance-assessments are available) only keep element types that a system-designer or librarian has deemed to be useful search-results highlighting if the user knows the schema of the collection and is able to specify the desired type of element , then the problem of redundancy is alleviated as few nested elements have the same type . but as we discussed in the introduction , users often do n't know what the name of an element in the collection is (is the vatican a country or a city ?) or they may not know how to compose structured-queries at all . a challenge in xml-retrieval related to nesting is that we may need to distinguish different contexts of a term when we compute term statistics for ranking , in particular inverse-document-frequency (idf) statistics as defined in section 6.2.1 (page) . for example , the term gates under the node author is unrelated to an occurrence under a content node like section if used to refer to the plural of gate . it makes little sense to compute a single-document frequency for gates in this example . one solution is to compute idf for xml-contextterm pairs , e.g. , to compute different idf weights for author # `` gates '' and section # `` gates '' . unfortunately , this scheme will run into sparse-data problems - that is , many xml-context pairs occur too rarely to reliably estimate df (see section 13.2 , page 13.2 , for a discussion of sparseness) . a compromise is only to consider the parent node of the term and not the rest of the path from the root to to distinguish contexts . there are still conflations of contexts that are harmful in this scheme . for instance , we do not distinguish names of authors and names of corporations if both have the parent node name . but most important distinctions , like the example contrast author # `` gates '' vs. section # `` gates '' , will be respected . figure 10.6 : schema heterogeneity : intervening nodes and mismatched names . in many cases , several different xml-schemas occur in a collection since the xml-documents in an ir application often come from more than one source . this phenomenon is called schema heterogeneity or schema diversity and presents yet another challenge . as illustrated in figure 10.6 comparable elements may have different names : creator in vs. author in . in other cases , the structural organization of the schemas may be different : author-names are direct descendants of the node author in , but there are the intervening nodes firstname and lastname in . if we employ strict matching of trees , then will retrieve neither nor although both documents are relevant . some form of approximate-matching of element names in combination with semi-automatic matching of different document-structures can help here . human editing of correspondences of elements in different schemas will usually do better than automatic methods . schema heterogeneity is one reason for query-document mismatches like and . another reason is that users often are not familiar with the element names and the structure of the schemas of collections they search as mentioned . this poses a challenge for interface-design in xml-retrieval . ideally , the user-interface should expose the tree structure of the collection and allow users to specify the elements they are querying . if we take this approach , then designing the query-interface in structured-retrieval is more complex than a search box for keyword-queries in unstructured retrieval . we can also support the user by interpreting all parent-child relationships in queries as descendant relationships with any number of intervening nodes allowed . we call such queries extended queries . the tree in figure 10.3 and in figure 10.6 are examples of extended queries . we show edges that are interpreted as descendant relationships as dashed arrows . in , a dashed arrow connects book and gates . as a pseudo-xpath notation for , we adopt book / / # `` gates '' : a book that somewhere in its structure contains the word gates where the path from the book node to gates can be arbitrarily long . the pseudo-xpath notation for the extended query that in addition specifies that gates occurs in a section of the book is book / / section / / # `` gates '' . it is convenient for users to be able to issue such extended queries without having to specify the exact structural configuration in which a query-term should occur - either because they do not care about the exact configuration or because they do not know enough about the schema of the collection to be able to specify it . figure 10.7 : a structural-mismatch between two queries and a document . in figure 10.7 , the user is looking for a chapter entitled fft (-rrb- . suppose there is no such chapter in the collection , but that there are references to books on fft (-rrb- . a reference to a book on fft is not exactly what the user is looking for , but it is better than returning nothing . extended queries do not help here . the extended query also returns nothing . this is a case where we may want to interpret the structural constraints specified in the query as hints as opposed to as strict conditions . as we will discuss in section 10.4 , users prefer a relaxed interpretation of structural constraints : elements that do not meet structural constraints perfectly should be ranked lower , but they should not be omitted from search-results .