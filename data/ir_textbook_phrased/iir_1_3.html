processing boolean-queries how do we process a query using an inverted-index and the basic boolean-retrieval model ? consider processing the simple conjunctive-query : over the inverted-index partially shown in figure 1.3 (page) . we : locate brutus in the dictionary retrieve its postings locate calpurnia in the dictionary retrieve its postings intersect the two postings lists , as shown in figure 1.5 . intersection merging merge algorithm figure : intersecting the postings lists for brutus and calpurnia from figure 1.3 . figure 1.6 : algorithm for the intersection of two postings lists and . there is a simple and effective method of intersecting postings lists using the merge algorithm (see figure 1.6) : we maintain pointers into both lists and walk through the two postings lists simultaneously , in time linear in the total number of postings entries . at each step , we compare the docid pointed to by both pointers . if they are the same , we put that docid in the results list , and advance both pointers . otherwise we advance the pointer pointing to the smaller docid . if the lengths of the postings lists are and , the intersection takes operations . formally , the complexity of querying is , where is the number of documents in the collection.our indexing-methods gain us just a constant , not a difference in time-complexity compared to a linear scan , but in practice the constant is huge . to use this algorithm , it is crucial that postings be sorted by a single global ordering . using a numeric sort by docid is one simple way to achieve this . we can extend the intersection operation to process more complicated queries like : query-optimization is the process of selecting how to organize the work of answering a query so that the least total amount of work needs to be done by the system . a major element of this for boolean-queries is the order in which postings lists are accessed . what is the best order for query-processing ? consider a query that is an and of terms , for instance : for each of the terms , we need to get its postings , then and them together . the standard heuristic is to process terms in order of increasing document-frequency : if we start by intersecting the two smallest postings lists , then all intermediate results must be no bigger than the smallest postings list , and we are therefore likely to do the least amount of total work . so , for the postings lists in figure 1.3 (page) , we execute the above query as : this is a first justification for keeping the frequency of terms in the dictionary : it allows us to make this ordering decision based on in-memory data before accessing any postings list . consider now the optimization of more general queries , such as : as before , we will get the frequencies for all terms , and we can then (conservatively) estimate the size of each or by the sum of the frequencies of its disjuncts . we can then process the query in increasing order of the size of each disjunctive term . figure 1.7 : algorithm for conjunctive-queries that returns the set of documents containing each term in the input list of terms . for arbitrary boolean-queries , we have to evaluate and temporarily store the answers for intermediate expressions in a complex expression . however , in many circumstances , either because of the nature of the query-language , or just because this is the most common type of query that users submit , a query is purely conjunctive . in this case , rather than viewing merging postings lists as a function with two inputs and a distinct output , it is more efficient to intersect each retrieved postings list with the current intermediate-result in memory , where we initialize the intermediate-result by loading the postings list of the least frequent term . this algorithm is shown in figure 1.7 . the intersection operation is then asymmetric : the intermediate results list is in memory while the list it is being intersected with is being read from disk . moreover the intermediate results list is always at least as short as the other list , and in many cases it is orders of magnitude shorter . the postings intersection can still be done by the algorithm in figure 1.6 , but when the difference between the list lengths is very-large , opportunities to use alternative techniques open up . the intersection can be calculated in place by destructively modifying or marking invalid items in the intermediate results list . or the intersection can be done as a sequence of binary searches in the long postings lists for each posting in the intermediate results list . another possibility is to store the long postings list as a hashtable , so that membership of an intermediate-result item can be calculated in constant rather than linear or log time . however , such alternative techniques are difficult to combine with postings list-compression of the sort discussed in chapter 5 . moreover , standard postings list-intersection operations remain necessary when both terms of a query are very common . exercises . for the queries below , can we still run through the intersection in time , where and are the lengths of the postings lists for brutus and caesar ? if not , what can we achieve ? brutus and not caesar brutus or not caesar extend the postings merge algorithm to arbitrary boolean-query formulas . what is its time-complexity ? for instance , consider : c. (brutus or caesar) and not (antony or cleopatra) can we always merge in linear-time ? linear in what ? can we do better than this ? we can use distributive-laws for and and or to rewrite queries . show how to rewrite the query in exercise 1.3 into disjunctive-normal-form using the distributive-laws . would the resulting query be more or less efficiently evaluated than the original form of this query ? is this result true in general or does it depend on the words and the contents of the document collection ? recommend a query-processing order for d. (tangerine or trees) and (marmalade or skies) and (kaleidoscope or eyes) given the following postings list sizes : term postings size eyes 213312 kaleidoscope 87009 marmalade 107913 skies 271658 tangerine 46653 trees 316812 if the query is : e. friends and romans and (not countrymen) how could we use the frequency of countrymen in evaluating the best query-evaluation order ? in particular , propose a way of handling negation in determining the order of query-processing . for a conjunctive-query , is processing postings lists in order of size guaranteed to be optimal ? explain why it is , or give an example where it is n't . write out a postings merge algorithm , in the style of figure 1.6 (page) , for an or query . how should the boolean-query and not be handled ? why is naive evaluation of this query normally very expensive ? write out a postings merge algorithm that evaluates this query efficiently .